{"version":3,"sources":["convert.service.js","engines/objectConverter.service.js","engines/objectConverter.service.spec.js","engines/queryStringConverter.service.js","engines/stringConverter.service.js","engines/stringConverter.service.spec.js"],"names":["angular","module","window","string","object","$objectConverter","Error","obj","newObj","keysToCamelCase","Convert","describe","_$objectConverter_","it","src","res","expect","toBeDefined","b","a","c","toBe","simple","more_snake_cased","snakeCased","moreSnakeCased","snake_cased","TypeError","toThrowError","keysToSnakeCase","moreCamelCased","camel_cased","more_camel_cased","camelCased","not","undefined","$stringConverter","str","s","convertCase","split","key","val","isDefined","isArray","push","parts","value","v","toJson","join","tryEncodeURIComponent","toSnakeCase","$window","String","trim","replace","$1","slice","ucfirst","Number","index","o","length","decodeURIComponent","_$stringConverter_","toCamelCase","toDasherized","toUcFirst"],"mappings":"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","file":"angular-convert.min.js","sourcesContent":["(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('Convert.Service', [\n  'Convert.StringConverter.Service',\n  'Convert.ObjectConverter.Service',\n  'Convert.QueryStringConverter.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('$convert', function(\n  $stringConverter, $objectConverter, $queryStringConverter\n) {\n  return {\n    string: $stringConverter,\n    object: $objectConverter,\n    queryString: $queryStringConverter,\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('Convert.ObjectConverter.Service', [\n  'Convert.StringConverter.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('$objectConverter', function($stringConverter) {\n\n  /**\n   * Helper to convert object keys using a specified string converter\n   */\n  function convertObjectKeys(obj, converter) {\n\n    //Must have object\n    if (!angular.isObject(obj)) {\n      throw new TypeError('Not an object');\n    }\n\n    //Validate case\n    if (typeof $stringConverter[converter] === 'undefined') {\n      throw new Error('Invalid converter: ' + converter);\n    }\n\n    //Initialize object\n    let newObj = {};\n\n    //Loop keys\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let newKey = $stringConverter[converter](key);\n        newObj[newKey] = angular.copy(obj[key]);\n      }\n    }\n\n    //Return object\n    return newObj;\n  }\n\n  /**\n   * Object converter\n   */\n  return {\n\n    /**\n     * Convert object keys to snake case\n     */\n    keysToSnakeCase(obj) {\n      return convertObjectKeys(obj, 'toSnakeCase');\n    },\n\n    /**\n     * Convert object keys to snake case\n     */\n    keysToCamelCase(obj) {\n      return convertObjectKeys(obj, 'toCamelCase');\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */\n\n/**\n * Specifications\n */\ndescribe('ObjectConverter', () => {\n\n  //Load module and service\n  beforeEach(module('Convert.ObjectConverter.Service'));\n\n  //Inject storage\n  let Convert;\n  beforeEach(inject((_$objectConverter_) => {\n    Convert = _$objectConverter_;\n  }));\n\n  /**\n   * Camel case conversion\n   */\n  describe('keysToCamelCase', () => {\n    it('should return an object when passed an object', () => {\n      let src = {};\n      let res = Convert.keysToCamelCase(src);\n      expect(typeof res).toBe('object');\n      expect(res).not.toBeNull();\n    });\n    it('should return an object with the same properties', () => {\n      let src = {a: 1, b: 2, c: 3};\n      let res = Convert.keysToCamelCase(src);\n      expect(res.a).toBeDefined();\n      expect(res.b).toBeDefined();\n      expect(res.c).toBeDefined();\n    });\n    it('should return an object with the same property values', () => {\n      let src = {a: 1, b: 2, c: 3};\n      let res = Convert.keysToCamelCase(src);\n      expect(res.a).toBe(src.a);\n      expect(res.b).toBe(src.b);\n      expect(res.c).toBe(src.c);\n    });\n    it('should not camel case simple keys', () => {\n      let src = {simple: 1};\n      let res = Convert.keysToCamelCase(src);\n      expect(res.simple).toBeDefined();\n    });\n    it('should camel case snake cased keys', () => {\n      let src = {snake_cased: 1, more_snake_cased: 2};\n      let res = Convert.keysToCamelCase(src);\n      expect(res.snakeCased).toBeDefined();\n      expect(res.moreSnakeCased).toBeDefined();\n    });\n    it('should not preserve the original keys', () => {\n      let src = {snake_cased: 1, more_snake_cased: 2};\n      let res = Convert.keysToCamelCase(src);\n      expect(res.snake_cased).not.toBeDefined();\n      expect(res.more_snake_cased).not.toBeDefined();\n    });\n    it('should throw a type error on invalid input', () => {\n      expect(Convert.keysToCamelCase).toThrowError(TypeError);\n      expect(() => {\n        Convert.keysToCamelCase(null);\n      }).toThrowError(TypeError);\n      expect(() => {\n        Convert.keysToCamelCase(1);\n      }).toThrowError(TypeError);\n      expect(() => {\n        Convert.keysToCamelCase('a');\n      }).toThrowError(TypeError);\n    });\n  });\n\n  /**\n   * Snake case conversion\n   */\n  describe('keysToSnakeCase', () => {\n    it('should return an object when passed an object', () => {\n      let src = {};\n      let res = Convert.keysToSnakeCase(src);\n      expect(typeof res).toBe('object');\n      expect(res).not.toBeNull();\n    });\n    it('should return an object with the same properties', () => {\n      let src = {a: 1, b: 2, c: 3};\n      let res = Convert.keysToSnakeCase(src);\n      expect(res.a).toBeDefined();\n      expect(res.b).toBeDefined();\n      expect(res.c).toBeDefined();\n    });\n    it('should return an object with the same property values', () => {\n      let src = {a: 1, b: 2, c: 3};\n      let res = Convert.keysToSnakeCase(src);\n      expect(res.a).toBe(src.a);\n      expect(res.b).toBe(src.b);\n      expect(res.c).toBe(src.c);\n    });\n    it('should not snake case simple keys', () => {\n      let src = {simple: 1};\n      let res = Convert.keysToSnakeCase(src);\n      expect(res.simple).toBeDefined();\n    });\n    it('should snake case camel cased keys', () => {\n      let src = {camelCased: 1, moreCamelCased: 2};\n      let res = Convert.keysToSnakeCase(src);\n      expect(res.camel_cased).toBeDefined();\n      expect(res.more_camel_cased).toBeDefined();\n    });\n    it('should not preserve the original keys', () => {\n      let src = {camelCased: 1, moreCamelCased: 2};\n      let res = Convert.keysToSnakeCase(src);\n      expect(res.camelCased).not.toBeDefined();\n      expect(res.moreCamelCased).not.toBeDefined();\n    });\n    it('should throw a type error on invalid input', () => {\n      expect(Convert.keysToSnakeCase).toThrowError(TypeError);\n      expect(() => {\n        Convert.keysToSnakeCase(null);\n      }).toThrowError(TypeError);\n      expect(() => {\n        Convert.keysToSnakeCase(1);\n      }).toThrowError(TypeError);\n      expect(() => {\n        Convert.keysToSnakeCase('a');\n      }).toThrowError(TypeError);\n    });\n  });\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('Convert.QueryStringConverter.Service', [\n  'Convert.StringConverter.Service',\n])\n\n/**\n * Factory definition\n */\n.factory('$queryStringConverter', function($stringConverter) {\n\n  /**\n   * Tries to decode an URI component without throwing an exception\n   */\n  function tryDecodeURIComponent(str) {\n    try {\n      return decodeURIComponent(str);\n    }\n    catch (e) {\n      //Fall through\n    }\n  }\n\n  /**\n   * Tries to encode an URI component without throwing an exception\n   */\n  function tryEncodeURIComponent(str, pctEncodeSpaces) {\n    try {\n      return encodeURIComponent(str)\n        .replace(/%40/g, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/g, '$')\n        .replace(/%2C/gi, ',')\n        .replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n    }\n    catch (e) {\n      //Fall through\n    }\n  }\n\n  /**\n   * Converts a string to a specific case\n   */\n  function convertToCase(str, convertCase) {\n    switch (convertCase) {\n      case 'snake':\n        return $stringConverter.toSnakeCase(str);\n      case 'camel':\n        return $stringConverter.toCamelCase(str);\n    }\n    return str;\n  }\n\n  /**\n   * Query string converter\n   */\n  return {\n\n    /**\n     * Parses an escaped url query string into key-value pairs\n     */\n    toObject(s, convertCase) {\n      let obj = {};\n      let kv, key, val;\n      angular.forEach((s || '').split('&'), (s) => {\n        if (!s) {\n          return;\n        }\n\n        //Split key/value and decode key\n        kv = s.replace(/\\+/g, '%20').split('=');\n        key = tryDecodeURIComponent(kv[0]);\n\n        //If not defined, exit\n        if (!angular.isDefined(key)) {\n          return;\n        }\n\n        //Convert case and get value\n        key = convertToCase(key, convertCase);\n        val = angular.isDefined(kv[1]) ? tryDecodeURIComponent(kv[1]) : true;\n\n        //Set property\n        if (!hasOwnProperty.call(obj, key)) {\n          obj[key] = val;\n        }\n        else if (angular.isArray(obj[key])) {\n          obj[key].push(val);\n        }\n        else {\n          obj[key] = [obj[key], val];\n        }\n      });\n      return obj;\n    },\n\n    /**\n     * Convert key-value pairs object to a parametrized query string\n     */\n    fromObject(obj, convertCase) {\n\n      //No obj?\n      if (!obj || !angular.isObject(obj)) {\n        return '';\n      }\n\n      //Initialize parts array\n      let parts = [];\n\n      //Loop the parameters\n      angular.forEach(obj, (value, key) => {\n\n        //Skip null/undefined values\n        if (value === null || angular.isUndefined(value)) {\n          return;\n        }\n\n        //Convert to array\n        if (!angular.isArray(value)) {\n          value = [value];\n        }\n\n        //Loop values\n        angular.forEach(value, (v) => {\n\n          //Handle objects\n          if (angular.isObject(v)) {\n            if (angular.isDate(v)) {\n              v = v.toISOString();\n            }\n            else {\n              v = angular.toJson(v);\n            }\n          }\n\n          //Convert case?\n          switch (convertCase) {\n            case 'snake':\n              key = $stringConverter.toSnakeCase(key);\n              break;\n            case 'camel':\n              key = $stringConverter.toCamelCase(key);\n              break;\n          }\n\n          //Push to parts\n          parts.push(\n            tryEncodeURIComponent(key) + '=' + tryEncodeURIComponent(v)\n          );\n        });\n      });\n\n      //Any parts?\n      if (parts.length > 0) {\n        return parts.join('&');\n      }\n\n      //No parts\n      return '';\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Module definition and dependencies\n */\nangular.module('Convert.StringConverter.Service', [])\n\n/**\n * Factory definition\n */\n.factory('$stringConverter', function($window) {\n  return {\n\n    /**\n     * Convert string to snake case\n     */\n    toSnakeCase(str) {\n      if (typeof str === 'number') {\n        return String(str);\n      }\n      else if (typeof str !== 'string') {\n        return '';\n      }\n      if ((str = String(str).trim()) === '') {\n        return '';\n      }\n      return str.replace(/(\\s*\\-*\\b\\w|[A-Z])/g, ($1) => {\n        $1 = $1.trim().toLowerCase().replace('-', '');\n        return ($1[0] === '_' ? '' : '_') + $1;\n      }).slice(1);\n    },\n\n    /**\n     * Convert string to camel case\n     */\n    toCamelCase(str, ucfirst) {\n      if (typeof str === 'number') {\n        return String(str);\n      }\n      else if (typeof str !== 'string') {\n        return '';\n      }\n      if ((str = String(str).trim()) === '') {\n        return '';\n      }\n      return str\n        .replace(/_+|\\-+/g, ' ')\n        .replace(/(?:^\\w|[A-Z]|\\b\\w|\\s+)/g, (match, index) => {\n          if (Number(match) === 0) {\n            return '';\n          }\n          return (index === 0 && !ucfirst) ?\n            match.toLowerCase() : match.toUpperCase();\n        });\n    },\n\n    /**\n     * Dasherize a string\n     */\n    toDasherized(str) {\n      if (typeof str === 'number') {\n        return String(str);\n      }\n      else if (typeof str !== 'string') {\n        return '';\n      }\n      if ((str = String(str).trim()) === '') {\n        return '';\n      }\n      str = str.replace(/\\s\\(/, '-(');\n      return str.replace(/(\\s*\\-*\\b\\w|[A-Z]|_[a-z])/g, ($1) => {\n        $1 = $1.replace('_', '-').trim().toLowerCase();\n        return ($1[0] === '-' ? '' : '-') + $1;\n      }).slice(1).replace(/\\(-/, '(');\n    },\n\n    /**\n     * Make the first letter of a string uppercase\n     */\n    toUcFirst(str) {\n      if (typeof str !== 'string' && typeof str !== 'number') {\n        return '';\n      }\n      str = String(str).trim();\n      if (str === '') {\n        return '';\n      }\n      return str[0].toUpperCase() + str.substr(1);\n    },\n\n    /**\n     * Base 64 decode URL string\n     */\n    fromBase64(str) {\n      let o = str.replace('-', '+').replace('_', '/');\n      switch (o.length % 4) {\n        case 0:\n          break;\n        case 2:\n          o += '==';\n          break;\n        case 3:\n          o += '=';\n          break;\n        default:\n          throw 'Illegal base64 url string';\n      }\n      try {\n        return decodeURIComponent($window.atob(o));\n      }\n      catch (e) {\n        //Fall through\n      }\n    },\n  };\n});\n\n})(window, window.angular);\n","(function(window, angular, undefined) {'use strict';\n\n/**\n * Specifications\n */\ndescribe('StringConverter', () => {\n\n  //Load module and service\n  beforeEach(module('Convert.StringConverter.Service'));\n\n  //Inject storage\n  let Convert;\n  beforeEach(inject((_$stringConverter_) => {\n    Convert = _$stringConverter_;\n  }));\n\n  /**\n   * Camel case conversion\n   */\n  describe('toCamelCase', () => {\n\n    //Tests\n    describe('camel casing', () => {\n      it('should camel case an already camel cased string', () => {\n        expect(Convert.toCamelCase('camelCase')).toBe('camelCase');\n      });\n      it('should camel case a snake cased string', () => {\n        expect(Convert.toCamelCase('camel_case')).toBe('camelCase');\n      });\n      it('should camel case a dasherized string', () => {\n        expect(Convert.toCamelCase('camel-case')).toBe('camelCase');\n      });\n      it('should camel case a string with spaces', () => {\n        expect(Convert.toCamelCase('camel case')).toBe('camelCase');\n      });\n      it('should camel case a string with multiple spaces', () => {\n        expect(Convert.toCamelCase('camel   case')).toBe('camelCase');\n        expect(Convert.toCamelCase('camel   ca se')).toBe('camelCaSe');\n      });\n      it('should camel case a mixed string', () => {\n        expect(Convert.toCamelCase(\n          'CamelCase With snake_case _and  dash-erized -andCamel'\n        ))\n          .toBe('camelCaseWithSnakeCaseAndDashErizedAndCamel');\n        expect(Convert.toCamelCase('camel_case With  vari-ety andCamel'))\n          .toBe('camelCaseWithVariEtyAndCamel');\n      });\n      it('should lowercase single letters', () => {\n        expect(Convert.toCamelCase('A')).toBe('a');\n        expect(Convert.toCamelCase('F')).toBe('f');\n        expect(Convert.toCamelCase('Z')).toBe('z');\n      });\n      it('should trim and camel case with leading/trailing spaces', () => {\n        expect(Convert.toCamelCase(' test_me ')).toBe('testMe');\n        expect(Convert.toCamelCase('  test_me')).toBe('testMe');\n        expect(Convert.toCamelCase('test_me  ')).toBe('testMe');\n        expect(Convert.toCamelCase('  test_me  ')).toBe('testMe');\n      });\n      it('should capitalize the first letter as well when requested', () => {\n        expect(Convert.toCamelCase('camelCase', true)).toBe('CamelCase');\n        expect(Convert.toCamelCase('camel-case', true)).toBe('CamelCase');\n        expect(Convert.toCamelCase('camel_case', true)).toBe('CamelCase');\n      });\n    });\n\n    //Numbers\n    describe('numbers', () => {\n      it('should accept numbers and return them as a string', () => {\n        expect(Convert.toCamelCase(123)).toBe('123');\n        expect(Convert.toCamelCase(1.23)).toBe('1.23');\n        expect(Convert.toCamelCase(0)).toBe('0');\n        expect(Convert.toCamelCase(-123)).toBe('-123');\n      });\n    });\n\n    //Invalid input\n    describe('invalid input', () => {\n      it('should return an empty string for empty strings', () => {\n        expect(Convert.toCamelCase('')).toBe('');\n      });\n      it('should return an empty string for booleans', () => {\n        expect(Convert.toCamelCase(true)).toBe('');\n        expect(Convert.toCamelCase(false)).toBe('');\n      });\n      it('should return an empty string for null', () => {\n        expect(Convert.toCamelCase(null)).toBe('');\n      });\n      it('should return an empty string for undefined', () => {\n        expect(Convert.toCamelCase(null)).toBe('');\n      });\n      it('should return an empty string for objects', () => {\n        expect(Convert.toCamelCase({})).toBe('');\n      });\n      it('should return an empty string for arrays', () => {\n        expect(Convert.toCamelCase([])).toBe('');\n      });\n    });\n  });\n\n  /**\n   * Snake case conversion\n   */\n  describe('toSnakeCase', () => {\n\n    //Tests\n    describe('snake casing', () => {\n      it('should snake case an already snake cased string', () => {\n        expect(Convert.toSnakeCase('snake_case')).toBe('snake_case');\n      });\n      it('should snake case a camel cased string', () => {\n        expect(Convert.toSnakeCase('snakeCase')).toBe('snake_case');\n        expect(Convert.toSnakeCase('SnakeCase')).toBe('snake_case');\n        expect(Convert.toSnakeCase('SnAkeCASe')).toBe('sn_ake_c_a_se');\n      });\n      it('should snake case a dasherized string', () => {\n        expect(Convert.toSnakeCase('snake-case')).toBe('snake_case');\n        expect(Convert.toSnakeCase('Snake-Case')).toBe('snake_case');\n      });\n      it('should snake case a string with spaces', () => {\n        expect(Convert.toSnakeCase('Snake Case')).toBe('snake_case');\n      });\n      it('should snake case a string with multiple spaces', () => {\n        expect(Convert.toSnakeCase('Snake   Case')).toBe('snake_case');\n        expect(Convert.toSnakeCase('Snake   Ca se')).toBe('snake_ca_se');\n      });\n      it('should snake case a mixed string', () => {\n        expect(Convert.toSnakeCase('Snake-Case mixEd Stri_ng te-st'))\n          .toBe('snake_case_mix_ed_stri_ng_te_st');\n        expect(Convert.toSnakeCase(\n          'CamelCase With snake_case _and  dash-erized -andCamel'\n        ))\n          .toBe('camel_case_with_snake_case_and_dash_erized_and_camel');\n      });\n      it('should lowercase single letters', () => {\n        expect(Convert.toSnakeCase('A')).toBe('a');\n        expect(Convert.toSnakeCase('F')).toBe('f');\n        expect(Convert.toSnakeCase('Z')).toBe('z');\n      });\n      it('should trim and snake case with leading/trailing spaces', () => {\n        expect(Convert.toSnakeCase(' TestMe ')).toBe('test_me');\n        expect(Convert.toSnakeCase('  TestMe')).toBe('test_me');\n        expect(Convert.toSnakeCase('TestMe  ')).toBe('test_me');\n        expect(Convert.toSnakeCase('  TestMe  ')).toBe('test_me');\n      });\n    });\n\n    //Numbers\n    describe('numbers', () => {\n      it('should accept numbers and return them as a string', () => {\n        expect(Convert.toSnakeCase(123)).toBe('123');\n        expect(Convert.toSnakeCase(1.23)).toBe('1.23');\n        expect(Convert.toSnakeCase(0)).toBe('0');\n        expect(Convert.toSnakeCase(-123)).toBe('-123');\n      });\n    });\n\n    //Invalid input\n    describe('invalid input', () => {\n      it('should return an empty string for empty strings', () => {\n        expect(Convert.toSnakeCase('')).toBe('');\n      });\n      it('should return an empty string for booleans', () => {\n        expect(Convert.toSnakeCase(true)).toBe('');\n        expect(Convert.toSnakeCase(false)).toBe('');\n      });\n      it('should return an empty string for null', () => {\n        expect(Convert.toSnakeCase(null)).toBe('');\n      });\n      it('should return an empty string for undefined', () => {\n        expect(Convert.toSnakeCase(null)).toBe('');\n      });\n      it('should return an empty string for objects', () => {\n        expect(Convert.toSnakeCase({})).toBe('');\n      });\n      it('should return an empty string for arrays', () => {\n        expect(Convert.toSnakeCase([])).toBe('');\n      });\n    });\n  });\n\n  /**\n   * Dasherize conversion\n   */\n  describe('toDasherized', () => {\n\n    //Tests\n    describe('dasherizing', () => {\n      it('should dasherize an already dasherized string', () => {\n        expect(Convert.toDasherized('dash-erized')).toBe('dash-erized');\n      });\n      it('should dasherize a snake cased string', () => {\n        expect(Convert.toDasherized('dash_erized')).toBe('dash-erized');\n      });\n      it('should dasherize a camel cased string', () => {\n        expect(Convert.toDasherized('dashErized')).toBe('dash-erized');\n        expect(Convert.toDasherized('DashErized')).toBe('dash-erized');\n      });\n      it('should dasherize a string with spaces', () => {\n        expect(Convert.toDasherized('dash erized')).toBe('dash-erized');\n      });\n      it('should dasherize a string with multiple spaces', () => {\n        expect(Convert.toDasherized('dash   erized')).toBe('dash-erized');\n        expect(Convert.toDasherized('dash   eri zed')).toBe('dash-eri-zed');\n      });\n      it('should dasherize a mixed string', () => {\n        expect(Convert.toDasherized(\n          'CamelCase With snake_case _and  dash-erized -andCamel'\n        ))\n          .toBe('camel-case-with-snake-case-and-dash-erized-and-camel');\n      });\n      it('should lowercase single letters', () => {\n        expect(Convert.toDasherized('A')).toBe('a');\n        expect(Convert.toDasherized('F')).toBe('f');\n        expect(Convert.toDasherized('Z')).toBe('z');\n      });\n      it('should trim and dasherize with leading/trailing spaces', () => {\n        expect(Convert.toDasherized(' test_me ')).toBe('test-me');\n        expect(Convert.toDasherized('  test_me')).toBe('test-me');\n        expect(Convert.toDasherized('test_me  ')).toBe('test-me');\n        expect(Convert.toDasherized('  test_me  ')).toBe('test-me');\n      });\n      it('should dasherize a string with brackets', () => {\n        expect(Convert.toDasherized('dash (erized)')).toBe('dash-(erized)');\n        expect(Convert.toDasherized('dash (erized) more'))\n          .toBe('dash-(erized)-more');\n      });\n    });\n\n    //Numbers\n    describe('numbers', () => {\n      it('should accept numbers and return them as a string', () => {\n        expect(Convert.toDasherized(123)).toBe('123');\n        expect(Convert.toDasherized(1.23)).toBe('1.23');\n        expect(Convert.toDasherized(0)).toBe('0');\n        expect(Convert.toDasherized(-123)).toBe('-123');\n      });\n    });\n\n    //Invalid input\n    describe('invalid input', () => {\n      it('should return an empty string for empty strings', () => {\n        expect(Convert.toDasherized('')).toBe('');\n      });\n      it('should return an empty string for booleans', () => {\n        expect(Convert.toDasherized(true)).toBe('');\n        expect(Convert.toDasherized(false)).toBe('');\n      });\n      it('should return an empty string for null', () => {\n        expect(Convert.toDasherized(null)).toBe('');\n      });\n      it('should return an empty string for undefined', () => {\n        expect(Convert.toDasherized(null)).toBe('');\n      });\n      it('should return an empty string for objects', () => {\n        expect(Convert.toDasherized({})).toBe('');\n      });\n      it('should return an empty string for arrays', () => {\n        expect(Convert.toDasherized([])).toBe('');\n      });\n    });\n  });\n\n  /**\n   * Ucfirst conversion\n   */\n  describe('toUcFirst', () => {\n\n    //Tests\n    describe('capitalization', () => {\n      it('should capitalize the first letter of a string', () => {\n        expect(Convert.toUcFirst('test')).toBe('Test');\n        expect(Convert.toUcFirst('test with spaces')).toBe('Test with spaces');\n      });\n      it('should capitalize single letters', () => {\n        expect(Convert.toUcFirst('a')).toBe('A');\n        expect(Convert.toUcFirst('f')).toBe('F');\n        expect(Convert.toUcFirst('z')).toBe('Z');\n      });\n      it('should leave capitalization of the rest of the string intact', () => {\n        expect(Convert.toUcFirst('tEsT')).toBe('TEsT');\n      });\n      it('should trim and capitalize with leading and trailing spaces', () => {\n        expect(Convert.toUcFirst(' test ')).toBe('Test');\n        expect(Convert.toUcFirst('  test')).toBe('Test');\n        expect(Convert.toUcFirst('test  ')).toBe('Test');\n        expect(Convert.toUcFirst('  test  ')).toBe('Test');\n      });\n    });\n\n    //Numbers\n    describe('numbers', () => {\n      it('should accept numbers and return them as a string', () => {\n        expect(Convert.toUcFirst(123)).toBe('123');\n        expect(Convert.toUcFirst(1.23)).toBe('1.23');\n        expect(Convert.toUcFirst(0)).toBe('0');\n        expect(Convert.toUcFirst(-123)).toBe('-123');\n      });\n    });\n\n    //Invalid input\n    describe('invalid input', () => {\n      it('should return an empty string for empty strings', () => {\n        expect(Convert.toUcFirst('')).toBe('');\n      });\n      it('should return an empty string for booleans', () => {\n        expect(Convert.toUcFirst(true)).toBe('');\n        expect(Convert.toUcFirst(false)).toBe('');\n      });\n      it('should return an empty string for null', () => {\n        expect(Convert.toUcFirst(null)).toBe('');\n      });\n      it('should return an empty string for undefined', () => {\n        expect(Convert.toUcFirst(null)).toBe('');\n      });\n      it('should return an empty string for objects', () => {\n        expect(Convert.toUcFirst({})).toBe('');\n      });\n      it('should return an empty string for arrays', () => {\n        expect(Convert.toUcFirst([])).toBe('');\n      });\n    });\n  });\n});\n\n})(window, window.angular);\n"]}